# Solid Principles
Conceptualised by Robert C Martin, SOLID principles are an object-oriented approach that are applied to software structure design. It ensures that the software is modular, easy to understand, debug and refactor.

![SOLID PRINCIPLES](https://user-images.githubusercontent.com/75598310/233797520-11268c95-7268-4cff-819e-e03aa69c8feb.jpg)


The word SOLID is an acrynom for:
- [Single Responsibility Principle](https://github.com/ramanks19/solid-principles/tree/main/1.%20Single%20Responsibility%20Principle)
- [Open Closed Principle](https://github.com/ramanks19/solid-principles/tree/main/2.%20Open%20Closed%20Principle)
- [Liskov Substitution Principle](https://github.com/ramanks19/solid-principles/tree/main/3.%20Liskov%20Substitution%20Principle)
- [Interface Segregation Principle](https://github.com/ramanks19/solid-principles/tree/main/4.%20Interface%20Segregation%20Principle)
- [Dependency Inversion Principle](https://github.com/ramanks19/solid-principles/tree/main/5.%20Dependency%20Inversion%20Principle)


**All SOLID principles are intertwined and interdependents. These are most effective when combined together.**

If we donâ€™t follow SOLID Principles we:  
1. End up with tight or strong coupling of the code with many other modules/applications
2. Tight coupling causes time to implement any new requirement, features or any bug fixes and some times it creates unknown issues
3. End up with a code which is not testable
4. End up with duplication of code
5. End up creating new bugs by fixing another bug
6. End up with many unknown issues in the application development cycle

Following SOLID Principles helps us to:  
1. Achieve reduction in complexity of code
2. Increase readability, extensibility and maintenance
3. Reduce error and implement Reusability
4. Achieve Better testability
5. Reduce tight coupling